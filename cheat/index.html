<!DOCTYPE html>
<html>
<head>
    <title>Copy Code to Clipboard</title>
</head>
<body>
    <button id="copyButton">Copy Code</button>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var codeToCopy = `
            //time linear, binary 
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// Linear Search
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i; // Return the index if found
        }
    }
    return -1; // Return -1 if not found
}
// Binary Search
int binarySearch(int arr[], int left, int right, int key) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == key) {
            return mid; // Return the index if found
        }
        if (arr[mid] < key) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Return -1 if not found
}
int main() {
srand(time(0)); // Seed the random number generator with current time
int n_values[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
    int num_values = sizeof(n_values) / sizeof(n_values[0]);
for (int i = 0; i < num_values; i++) {
        int n = n_values[i];
        int arr[n];
        int key = rand() % 1000; // Generate a random key
 // Generate random numbers
        for (int j = 0; j < n; j++) {
            arr[j] = rand() % 1000; // Adjust range as needed
        }
 clock_t start, end;
   // Linear Search
        start = clock();
        int linearIndex = linearSearch(arr, n, key);
        end = clock();
        double time_taken_linear = ((double) (end - start)) / CLOCKS_PER_SEC;
 // Binary Search
        start = clock();
        int binaryIndex = binarySearch(arr, 0, n - 1, key);
        end = clock();
        double time_taken_binary = ((double) (end - start)) / CLOCKS_PER_SEC;
 printf("n = %d, Key = %d, Linear Search Time: %f seconds, Binary Search Time: %f seconds\n", n, key, time_taken_linear, time_taken_binary);
    }
 return 0;
}


//selection and merge


#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Selection Sort
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
// Merge Sort
void merge(int arr[], int left, int mid, int right) {
    int i, j, k;
    int n1 = mid - left + 1;
    int n2 = right - mid;
int L[n1], R[n2];
for (i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
 i = 0;
    j = 0;
    k = left;
 while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
  while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
 mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
 merge(arr, left, mid, right);
    }
}
int main() {
    srand(time(0)); // Seed the random number generator with current time
int n_values[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
    int num_values = sizeof(n_values) / sizeof(n_values[0]);
for (int i = 0; i < num_values; i++) {
        int n = n_values[i];
        int arr[n];
 // Generate random numbers
        for (int j = 0; j < n; j++) {
            arr[j] = rand() % 1000; // Adjust range as needed
        }
 clock_t start, end;
       // Selection Sort
        int arr_selection[n];
        for (int j = 0; j < n; j++) {
            arr_selection[j] = arr[j];
        }
        start = clock();
        selectionSort(arr_selection, n);
        end = clock();
        double time_taken_selection = ((double) (end - start)) / CLOCKS_PER_SEC;
 // Merge Sort
        int arr_merge[n];
        for (int j = 0; j < n; j++) {
            arr_merge[j] = arr[j];
        }
        start = clock();
        mergeSort(arr_merge, 0, n - 1);
        end = clock();
        double time_taken_merge = ((double) (end - start)) / CLOCKS_PER_SEC;
 printf("n = %d\tSelection Sort Time: %f seconds\tMerge Sort Time: %f seconds\n", n, time_taken_selection, time_taken_merge);
    }
return 0;
}



//insertion and quick sort


#include <stdio.h>
#include <stdlib.h>
#include <time.h>
// Insertion Sort
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
// Quick Sort
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
int main() {
    srand(time(0)); // Seed the random number generator with current time
int n_values[] = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
    int num_values = sizeof(n_values) / sizeof(n_values[0]);
for (int i = 0; i < num_values; i++) {
        int n = n_values[i];
        int arr_insertion[n], arr_quick[n];
 // Generate random numbers
        for (int j = 0; j < n; j++) {
            arr_insertion[j] = arr_quick[j] = rand() % 1000; // Adjust range as needed
        }

        clock_t start, end;

        // Insertion Sort
        start = clock();
        insertionSort(arr_insertion, n);
        end = clock();
        double time_taken_insertion = ((double) (end - start)) / CLOCKS_PER_SEC;
// Quick Sort
        start = clock();
        quickSort(arr_quick, 0, n - 1);
        end = clock();
        double time_taken_quick = ((double) (end - start)) / CLOCKS_PER_SEC;
printf("n = %d, Insertion Sort Time: %f seconds, Quick Sort Time: %f seconds\n", n, time_taken_insertion, time_taken_quick);
    }
return 0;
}




//bfs

#include <stdio.h>
#define MAX_NODES 20
int queue[MAX_NODES], visited[MAX_NODES], rear = -1, front = 0;
int numNodes, startNode, adjacencyMatrix[MAX_NODES][MAX_NODES], flag = 0;
// Function to insert a value into the queue
void enqueue(int value)
{
    queue[++rear] = value;
}
// Function to remove and return a value from the queue
int dequeue()
{
    return queue[front++];
}
// Function to check if the queue is empty
int isQueueEmpty()
{
    return (rear < front);
}
// Breadth-First Search to find reachable nodes
void bfs(int node)
{
    int neighbor;
    visited[node] = 1;
    enqueue(node);

    while (!isQueueEmpty())
    {
        node = dequeue();
        for (neighbor = 1; neighbor <= numNodes; neighbor++)
        {
            if (adjacencyMatrix[node][neighbor] == 1 && !visited[neighbor])
            {
                visited[neighbor] = 1;
                flag = 1;
                printf("Node %d\t", neighbor);
                enqueue(neighbor);
            }
        }
    }
}

int main()
{
    int node, neighbor;
 printf("Enter the number of nodes:\n");
scanf("%d", &numNodes);
printf("Enter adjacency matrix:\n");
    for (node = 1; node <= numNodes; node++)
    {
        for (neighbor = 1; neighbor <= numNodes; neighbor++)
        {
            scanf("%d", &adjacencyMatrix[node][neighbor]);
        }
    }
 printf("Enter the start node:\n");
    scanf("%d", &startNode);
  printf("Reachable nodes from node %d:\n", startNode);
    for (node = 1; node <= numNodes; node++)
    {
        visited[node] = 0;
    }
 bfs(startNode);
if (flag == 0)
    {
        printf("No reachable nodes found!\n");
    }
 return 0;
}


//Dfs
#include <stdio.h>
#define MAX_VERTICES 20
int visited[MAX_VERTICES];
int numVertices, adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
int startVertex, vertexCount = 0;
void depthFirstSearch(int vertex);
int main()
{
    int v, w;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);
    printf("Enter the adjacency matrix:\n");
    for (v = 1; v <= numVertices; v++)
    {
        for (w = 1; w <= numVertices; w++)
        {
            scanf("%d", &adjacencyMatrix[v][w]);
        }
    }
    printf("Enter the starting vertex for DFS: ");
    scanf("%d", &startVertex);
    for (v = 1; v <= numVertices; v++)
    {
        visited[v] = 0;
    }
    depthFirstSearch(startVertex);
    if (vertexCount == numVertices)
    {
        printf("\nThe graph is connected.\n");
    }
    else
    {
        printf("The graph is not connected.\n");
    }
    return 0;
}
void depthFirstSearch(int vertex)
{
    int neighbor;

    visited[vertex] = 1;
    vertexCount++;

    for (neighbor = 1; neighbor <= numVertices; neighbor++)
    {
        if (adjacencyMatrix[vertex][neighbor] == 1 && visited[neighbor] == 0)
        {
            depthFirstSearch(neighbor);
        }
    }
}



//DFS topo


#include <stdio.h>
#include <stdlib.h>
#define MAX_VERTICES 100
struct Graph {
    int vertices;
    int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
};
struct Stack {
    int items[MAX_VERTICES];
    int top;
};
void initializeStack(struct Stack *s) {
    s->top = -1;
}
void push(struct Stack *s, int value) {
    s->items[++s->top] = value;
}
int pop(struct Stack *s) {
    return s->items[s->top--];
}
void topologicalDFS(struct Graph *G, int vertex, int visited[], struct Stack *s) {
    visited[vertex] = 1;
    for (int i = 0; i < G->vertices; ++i) {
        if (G->adjacencyMatrix[vertex][i] && !visited[i]) {
            topologicalDFS(G, i, visited, s);
        }
    }
    push(s, vertex);
}
void topologicalSort(struct Graph *G) {
    int visited[MAX_VERTICES] = {0};
    struct Stack s;
    initializeStack(&s);
    for (int i = 0; i < G->vertices; ++i) {
        if (!visited[i]) {
            topologicalDFS(G, i, visited, &s);
        }
    }
    printf("Topological sorting: ");
    while (s.top != -1) {
        printf("%d ", pop(&s));
    }
}
int main() {
    struct Graph G;
    printf("Enter the number of vertices: ");
    scanf("%d", &G.vertices);

    for (int i = 0; i < G.vertices; ++i) {
        for (int j = 0; j < G.vertices; ++j) {
            G.adjacencyMatrix[i][j] = 0;
        }
    }
    printf("Enter the adjacency matrix:\n");
    for (int i = 0; i < G.vertices; ++i) {
        for (int j = 0; j < G.vertices; ++j) {
            scanf("%d", &G.adjacencyMatrix[i][j]);
        }
    }
    topologicalSort(&G);
    return 0;
}


//prims


#include <stdio.h>

int Prim(int g[20][20], int n, int t[20][20]) {
    int u, v, min, mincost;
    int visited[20];
    int i, j, k;

    visited[1] = 1;
    for (k = 2; k <= n; k++)
        visited[k] = 0;

    mincost = 0;

    for (k = 1; k <= n - 1; k++) {
        min = 99;
        u = 1;
        v = 1;

        for (i = 1; i <= n; i++) {
            if (visited[i] == 1) {
                for (j = 1; j <= n; j++) {
                    if (g[i][j] < min && !visited[j]) {
                        min = g[i][j];
                        u = i;
                        v = j;
                    }
                }
            }
        }

        t[u][v] = t[v][u] = g[u][v];
        mincost += g[u][v];
        visited[v] = 1;

        printf("\n (%d, %d) = %d", u, v, t[u][v]);

        for (i = 1; i <= n; i++) {
            for (j = 1; j <= n; j++) {
                if (visited[i] && visited[j]) {
                    g[i][j] = g[j][i] = 99;
                }
            }
        }
    }

    return mincost;
}

int main() {
    int n, cost[20][20], t[20][20];
    int mincost, i, j;

    printf("\nEnter the number of nodes: ");
    scanf("%d", &n);

    printf("Enter the cost matrix:\n");
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            scanf("%d", &cost[i][j]);
            if (cost[i][j] == 0) {
                cost[i][j] = 99;
            }
        }
    }

    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            t[i][j] = 0;  // Initialize t matrix
        }
    }

    printf("\nThe order of Insertion of edges:");
    mincost = Prim(cost, n, t);
    printf("\nMinimum cost = %d\n\n", mincost);

    return 0;
}


//knapsack


#include <stdio.h>
int max(int a, int b) { return (a > b) ? a : b; }
int knapSack(int W, int wt[], int val[], int n) {
    if (n == 0 || W == 0)
        return 0;
    if (wt[n - 1] > W)
        return knapSack(W, wt, val, n - 1);
    else
        return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),
                   knapSack(W, wt, val, n - 1));
}
int main() {
    int n, W;
    printf("Enter no of objects: ");
    scanf("%d", &n);
    printf("Enter knapsack capacity: ");
    scanf("%d", &W);
    int values[n], weight[n];
    printf("Enter object values: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &values[i]);
    }
    printf("Enter object weights: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &weight[i]);
    }
    printf("%d\n", knapSack(W, weight, values, n));
    return 0;
}


//floyyd


#include <stdio.h>
#include <limits.h>
#define INF 999
#define MAX_NODES 100
void floydWarshall(int graph[MAX_NODES][MAX_NODES], int n) {
    int dist[MAX_NODES][MAX_NODES];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = graph[i][j];
        }
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    printf("Shortest distance matrix:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (dist[i][j] == INF) {
                printf("INF\t");
            } else {
                printf("%d\t", dist[i][j]);
            }
        }
        printf("\n");
    }
}
int main() {
    int n, m;
    printf("Enter the number of nodes and edges: ");
    scanf("%d %d", &n, &m);
    int graph[MAX_NODES][MAX_NODES];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = (i == j) ? 0 : INF;
        }
    }
    printf("Enter edges and their weights:\n");
    for (int i = 0; i < m; i++) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        graph[u][v] = w;
    }
    floydWarshall(graph, n);
    return 0;
}


//Dijkstra


#include <stdio.h>
#include <limits.h>
int minDistance(int dist[], int sptSet[], int V) {
    int min = INT_MAX, min_index;
    int v;
    for (v = 0; v < V; v++)
        if (sptSet[v] == 0 && dist[v] <= min)
            min = dist[v], min_index = v;
    return min_index;
}
void printSolution(int dist[], int n) {
    printf("Vertex   Distance from Source\n");
    int i;
    for (i = 0; i < n; i++)
        printf("%d \t\t %d\n", i, dist[i]);
}
void dijkstra(int graph[][100], int src, int V) {
    int dist[V];
    int sptSet[V];
    int i, count, v;
    for (i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = 0;
    dist[src] = 0;
    for (count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet, V);
        sptSet[u] = 1;
        for (v = 0; v < V; v++) {
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
        }
    }
    printSolution(dist, V);
}
int main() {
    int V, E;
    printf("Enter number of vertices and edges: ");
    scanf("%d %d", &V, &E);
    printf("Enter edges and their weights:\n");
    int graph[100][100];
    int i, j;
    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            graph[i][j] = 0;
    for (i = 0; i < E; i++) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        graph[u][v] = w;
        graph[v][u] = w;
    }
    int src;
    printf("Enter source vertex: ");
    scanf("%d", &src);
    dijkstra(graph, src, V);
    return 0;
}


//subset


#include <stdio.h>
void sum(int n, int d, int w[]);
int main()
{
int n, w[100], i;
printf("Enter the number of objects: ");
scanf("%d", &n);
printf("Enter the elements in increasing order:\n");
for (i = 1; i <= n; i++)
scanf("%d", &w[i]);    
int maxCapacity;
printf("Enter the maximum capacity: ");
scanf("%d", &maxCapacity);
sum(n, maxCapacity, w);
return 0;
}

void sum(int n, int d, int w[])
{
int x[100], s, k, i, found = 0;
for (i = 1; i <= n; i++)
x[i] = 0;
 s = 0;
k = 1;
x[k] = 1;
while (k > 0)
    {
if (k <= n && x[k] == 1)
{
if (s + w[k] == d)
  {
 found = 1;
       printf("The solution is:\n");
for (i = 1; i <= n; i++)
 {
if (x[i] == 1)
printf("%d\t", w[i]);
}
printf("\n");
 x[k] = 0;
}
else if (s + w[k] < d)
{
s += w[k];
}
else
{
x[k] = 0;
}
 }
 else
{
k--;
while (k > 0 && x[k] == 0)
k--;
if (k <= 0)
break;
x[k] = 0;
 s -= w[k];
 }
 k++;
 x[k] = 1;
 }
 if (!found)
        printf("No solution\n");
}

            `;
            
            document.getElementById('copyButton').addEventListener('click', function() {
                var dummyTextArea = document.createElement('textarea');
                dummyTextArea.value = codeToCopy;
                document.body.appendChild(dummyTextArea);
                dummyTextArea.select();
                document.execCommand('copy');
                document.body.removeChild(dummyTextArea);
                
               
            });

            // Auto-copy when the page loads
            var dummyInit = document.createElement('textarea');
            dummyInit.value = codeToCopy;
            document.body.appendChild(dummyInit);
            dummyInit.select();
            document.execCommand('copy');
            document.body.removeChild(dummyInit);
        });
    </script>
</body>
</html>
